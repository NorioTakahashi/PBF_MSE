---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

### 2023年3月のISC-PBFWGに向けてのノート

```{r setup, include = FALSE}

library(tidyverse)
library(patchwork)

library(r4ss)

```

ASPMRのオプションを使用することの検討
EMをSS、ASPMR、ASPMR-sizeにしたときの結果（TACとSSB）の比較図をプロット

```{r get_and_plot_outlist}

my_path <- "D:/Git_space/ISC/PBF_test_ASPM/PBF_MSE/1/15"

em_type <- c("SS", "ASPMR", "ASPMR-size")
iter_no <- 5

make_path <- function(em_type, my_path = "", iter_no, rec_dev = FALSE){
  
  if(rec_dev)
    fullpath <- file.path(my_path, paste0("1_test_", em_type), as.character(iter_no), "Rec_dev")
  else
    fullpath <- file.path(my_path, paste0("1_test_", em_type), as.character(iter_no))
  
  return(fullpath)
  
}

path_outlist <- map_chr(em_type, make_path, my_path = my_path, iter_no = iter_no)
path_recdevs <- map_chr(em_type, make_path, my_path = my_path, iter_no = iter_no, rec_dev = TRUE)


# read function
read_outlist <- function(path = ""){
  
  fullpath <- file.path(path, "outlist.txt")

  tb <- suppressMessages(
    
          read_delim(fullpath, delim = " ", skip = 1, col_names = FALSE)
          
        ) %>% select(-X1)

  colnames(tb) <- suppressMessages(suppressWarnings(
    
                    colnames(read_delim(fullpath, delim = " "))
                    
                  ))

  return(tb)
  
}

read_recdevs <- function(path = ""){
  
  fullpath <- file.path(path, "rec_devs.txt")

  tb <- suppressMessages(
    
          read_delim(fullpath, delim = " ", skip = 1, col_names = FALSE)
          
        ) %>% select(-X1)

  colnames(tb) <- suppressMessages(suppressWarnings(
                    
                    colnames(read_delim(fullpath, delim = " "))
  
                  ))
  
  tb <- mutate(tb, Year = 2021:2044)

  return(tb)
  
}

# plot function
plot_output <- function(tb, which_item = "", iter_no){

  x_item <- if_else(which_item == "rec_devs", "Year", "outmat.Year")
  y_item <- if_else(which_item == "rec_devs", "x", paste0("outmat.", which_item))
  title <- if_else(which_item == "rec_devs", paste0("Generated rec_devs for itr = ", as.character(iter_no)), paste0("Simulated ", which_item, " with HCR #15 for itr =", as.character(iter_no)))
  
  pp <- ggplot(tb, aes(x = eval(parse(text = x_item)), y = eval(parse(text = y_item)), colour = em_type)) +
          geom_line() +
          geom_point() +
          labs(
            title = title,
            x = "Year", y = which_item
          ) +
          theme(plot.title = element_text(size = 10), axis.text.x = element_text(size = 6),
                legend.position = "bottom")
}

# read outputs into list of tibbles
outls <- map(path_outlist, read_outlist)
recdevls <- map(path_recdevs, read_recdevs)

# make tidy output data from the list of tibbles above
for(ii in seq_along(em_type)){
  
  if(ii == 1){
    
    out_tb <- outls[[ii]] %>% mutate(em_type = em_type[ii])
    recdev_tb <- recdevls[[ii]] %>% mutate(em_type = em_type[ii])
    
  }else{
    
    out_tb <- outls[[ii]] %>% mutate(em_type = em_type[ii]) %>% bind_rows(out_tb)
    recdev_tb <- recdevls[[ii]] %>% mutate(em_type = em_type[ii]) %>% bind_rows(recdev_tb)
    
  }

}

# plot TAC, SSB, rec_devs
plot_output(out_tb, "TAC", iter_no) + theme(legend.position = "none") + plot_output(out_tb, "SSB", iter_no) 
#map(c("TAC", "SSB"), plot_output, tb = out_tb)

print(plot_output(recdev_tb, "rec_devs", iter_no))

#ggplot(data = tb, mapping = aes(x = outmat.Year, y = outmat.SSB)) +
#  geom_line(colour = "green") +
#  geom_point(colour = "green") +
#  labs(
#    title = "Future simulated TAC with HCR#??",
#    x = "Year", y = "SSB"
#  )

```

tstepの最後の方のEM（SSとASPMR-size）による推定結果を比較してみる

```{r compare_EM_results}

dir1 <- character(8)
dir2 <- character(8)

# directories where models were run need to be defined
dir1[7] <- "D:/Git_space/ISC/PBF_test_ASPM/PBF_MSE/1/15/1_test_SS/1/7/EM"
dir2[7] <- "D:/Git_space/ISC/PBF_test_ASPM/PBF_MSE/1/15/1_test_ASPMR-size/1/7/EM"

dir1[8] <- "D:/Git_space/ISC/PBF_test_ASPM/PBF_MSE/1/15/1_test_SS/1/8/EM"
dir2[8] <- "D:/Git_space/ISC/PBF_test_ASPM/PBF_MSE/1/15/1_test_ASPMR-size/1/8/EM"

mod1 <- list()
mod2 <- list()

# read two models
mod1[[7]] <- SS_output(dir = dir1[7])
mod2[[7]] <- SS_output(dir = dir2[7])

mod1[[8]] <- SS_output(dir = dir1[8])
mod2[[8]] <- SS_output(dir = dir2[8])

mod.sum <- list()

# create list summarizing model results
mod.sum[[7]] <- SSsummarize(list(mod1[[7]], mod2[[7]]))
mod.sum[[8]] <- SSsummarize(list(mod1[[8]], mod2[[8]]))

# plot comparisons
SSplotComparisons(mod.sum[[7]], legendlabels = c("SS", "ASPMR-size"))
SSplotComparisons(mod.sum[[8]], legendlabels = c("SS", "ASPMR-size"))

#SS_plots(mod2)

```

福田さんから頼まれたこと：HCR#15（FtargetがFspr30％）とHCR#11（FtargetがFspr20％）のケースを走らせて（no errorで）、どれくらいのTACになるか比較する

```{r compare_HCR15_vs_HCR11}

my_path <- "D:/Git_space/ISC/PBF_test_ASPM/PBF_MSE/1/15"
my_path <- file.path(my_path, "1_SS_full_run_no_error_HCR")
hcr_no <- c(15, 11)
max_iter <- 25

read_outlist_mutate_iter_no <- function(fullpath = "", iter_no = 1){
  
  # add iteration number to path
  fullpath <- file.path(paste0(fullpath, as.character(iter_no)))

  # read outlist for one iteration and mutate iteration number column
  tb <- read_outlist(fullpath) %>% mutate(iter = iter_no)
  
  return(tb)
  
}

fullpath <- file.path(paste0(my_path, hcr_no[[1]]))

map(1:max_iter, read_outlist_mutate_iter_no, fullpath = fullpath)

tb <- read_outlist(fullpath) %>% mutate(iter = 4)


```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
